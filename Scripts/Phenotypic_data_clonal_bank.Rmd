---
title: "Phenotypic_data_clonal_bank"
author: "Thomas Francisco"
date: "2024-09-16"
output:
  html_document:
    number_sections: true #titles
    toc: true #table of content
    toc_float: true # enable the toc to be on the side of the text, always visible
    collapsed: True #control if the toc label will only display top level titles
    toc_depth: 3
---

```{r library, message=FALSE, warning=FALSE, include=FALSE}
knitr::opts_chunk$set(cache = FALSE)
#rm(list = ls()) 
library(MCMCglmm)
library(lme4)
library(coda)
library(parallel)
library(dplyr)
library(stargazer)
library(ggplot2)
library(pastecs)
library(readxl)
library(purrr)
library(QGglmm)
library(purrr)
library(coda)
library(writexl)
```

# Introduction

The goal of this script is to estimate BLUP values for the phenotypic data, which will be used to evaluate genomic offset predictions. BLUP estimates allow us to generate population-level phenotypic values for each trait while accounting for covariates such as genotype for clones, tree ID when multiple measurements per tree exist, and tree size to account for age in growth-related traits.

Depending on the trait, we will select a specific period for climate data extraction. For all traits, the initial year is 1992 (the year of establishment of the clonal bank), with the following end years:  
- 2021 for leaf thickness  
- 2012 for shoot volume, stem length, spring elongation, and total open male strobili  

# Phenotypic data

We loaded the phenotypic traits associated with:

Growth -> Shoot volume
Growth_pheno -> spring elongation
Repro_pheno -> total open strobili
leaf_traits -> leaf thickness

The first step is to load the functions used in the analyses.
```{r function}
clean.MCMC <- function(x) {
  sols <- summary(x)$solutions  ## pull out relevant info from model summary
  Gcovs <- summary(x)$Gcovariances
  Rcovs <- summary(x)$Rcovariances
  fixed <- data.frame(row.names(sols), sols, row.names = NULL)  ## convert to dataframes with the row.names as the first col
  random <- data.frame(row.names(Gcovs), Gcovs, row.names = NULL)
  residual <- data.frame(row.names(Rcovs), Rcovs, row.names = NULL)
  names(fixed)[names(fixed) == "row.names.sols."] <- "variable"  ## change the columns names to variable, so they all match
  names(random)[names(random) == "row.names.Gcovs."] <- "variable"
  names(residual)[names(residual) == "row.names.Rcovs."] <- "variable"
  fixed$effect <- "fixed"  ## add ID column for type of effect (fixed, random, residual)
  random$effect <- "random"
  residual$effect <- "residual"
  modelTerms <- as.data.frame(bind_rows(fixed, random, residual))  # merge it all together
}

plot.estimates <- function(x) {
  if (class(x) != "summary.mcmc")
    x <- summary(x)
  n <- dim(x$statistics)[1]
  par(mar=c(2, 9, 4, 1))
  plot(x$statistics[,1], n:1,
       yaxt="n", ylab="",
       xlim=range(x$quantiles)*1.2,
       pch=19,
       main="Posterior means and 95% credible intervals")
  grid()
  axis(2, at=n:1, rownames(x$statistics), las=2)
  arrows(x$quantiles[,1], n:1, x$quantiles[,5], n:1, code=0)
  abline(v=0, lty=2)
}

myFun_h2Qst1 <- function(mcmc){  
  out <- c(
    posterior.mode((mcmc$VCV[,2])/(rowSums(mcmc$VCV))),
    HPDinterval((mcmc$VCV[,2])/(rowSums(mcmc$VCV)))[1],
    HPDinterval((mcmc$VCV[,2])/(rowSums(mcmc$VCV)))[2],
    posterior.mode((mcmc$VCV[,2])/((mcmc$VCV[,2])+(mcmc$VCV[,3]))),
    HPDinterval((mcmc$VCV[,2])/((mcmc$VCV[,2])+(mcmc$VCV[,3])))[1],
    HPDinterval((mcmc$VCV[,2])/((mcmc$VCV[,2])+(mcmc$VCV[,3])))[2],
    posterior.mode((mcmc$VCV[,1])/(rowSums(mcmc$VCV))),
    HPDinterval((mcmc$VCV[,1])/(rowSums(mcmc$VCV)))[1],
    HPDinterval((mcmc$VCV[,1])/(rowSums(mcmc$VCV)))[2],
    posterior.mode((mcmc$VCV[,1])/(2*(mcmc$VCV[,2])+(mcmc$VCV[,1]))),
    HPDinterval((mcmc$VCV[,1])/(2*(mcmc$VCV[,2])+(mcmc$VCV[,1])))[1],
    HPDinterval((mcmc$VCV[,1])/(2*(mcmc$VCV[,2])+(mcmc$VCV[,1])))[2]
  )
  names(out) <- c("H2c_all","lo.ci.H2c_all","up.ci.H2c_all" ,"H2c","lo.ci.H2c","up.ci.H2c" ,"H2p","lo.ci.H2p","up.ci.H2p" ,"Qst","lo.ci.Qst","up.ci.Qst")
  return(out)}

# for the logit link, which is used when family=categorical
myFun_h2Qst2 <- function(mcmc){  
  out <- c(
    posterior.mode((mcmc$VCV[,2])/(rowSums(mcmc$VCV)+(pi^2)/3)),
    HPDinterval((mcmc$VCV[,2])/(rowSums(mcmc$VCV)+(pi^2)/3))[1],
    HPDinterval((mcmc$VCV[,2])/(rowSums(mcmc$VCV)+(pi^2)/3))[2],
    posterior.mode((mcmc$VCV[,2])/((mcmc$VCV[,2])+(mcmc$VCV[,3])+(pi^2)/3)),
    HPDinterval((mcmc$VCV[,2])/((mcmc$VCV[,2])+(mcmc$VCV[,3])+(pi^2)/3))[1],
    HPDinterval((mcmc$VCV[,2])/((mcmc$VCV[,2])+(mcmc$VCV[,3])+(pi^2)/3))[2],
    posterior.mode(((mcmc$VCV[,1]))/(rowSums(mcmc$VCV)+(pi^2)/3)),
    HPDinterval(((mcmc$VCV[,1]))/(rowSums(mcmc$VCV)+(pi^2)/3))[1],
    HPDinterval(((mcmc$VCV[,1]))/(rowSums(mcmc$VCV)+(pi^2)/3))[2],
    posterior.mode((mcmc$VCV[,1])/(2*(mcmc$VCV[,2])+(mcmc$VCV[,1]))),
    HPDinterval((mcmc$VCV[,1])/(2*(mcmc$VCV[,2])+(mcmc$VCV[,1])))[1],
    HPDinterval((mcmc$VCV[,1])/(2*(mcmc$VCV[,2])+(mcmc$VCV[,1])))[2]
  )
  names(out) <- c("H2c_all","lo.ci.H2c_all","up.ci.H2c_all" ,"H2c","lo.ci.H2c","up.ci.H2c" ,"H2pc","lo.ci.H2pc","up.ci.H2pc" ,"Qst","lo.ci.Qst","up.ci.Qst")
  return(out)}
```

## Data
```{r phenotypic data}
list_traits <- c("Shoot_Growth","Basal_area","Shoot_Elongation","Male_Strobili","leaf_traits")
list_names <- c("growth","growth_bis","growth_pheno","repro_pheno","leaf_traits")

for(x in 1: length(list_traits)){
  
  trait <- list_traits[x]
  name <- list_names[x]
  
  path <- paste0("C:/Users/tfrancisco/Documents/Thesis/Data/Species/Taxus_baccata/phenotypic_data/common_garden/Individual_level_data/Taxus_",trait,".xlsx")
phenotypic_data <- read_excel(path, na="NA")

assign(paste0("phenotypic_data_",name),phenotypic_data)
}
```

## Selection of the period

For each trait, we calculated average values across years, as trait values in a given year are influenced by conditions and events from previous years. We retained the maximum number of sampling years while also maximizing the number of trees.
```{r Growth, message=FALSE, warning=FALSE}
#Growth

##Shootvol
#Identify the number of measurement per plant
phenotypic_data_growth_table <- data.frame(table(phenotypic_data_growth$Plant))

#Filter the number of measurement to keep the maximum number of individuals
phenotypic_data_growth_filtered <- phenotypic_data_growth %>%
  filter(Plant %in% phenotypic_data_growth_table$Var1[phenotypic_data_growth_table$Freq == 4])

#Mean values of the traits per plant
mean_traits_shootvol <- phenotypic_data_growth_filtered %>%
  group_by(Plant) %>%
  summarize(mean_AverageShootVolume = mean(AverageShootVolume.mm3, na.rm = TRUE),
            mean_StemLength = mean(StemLength.cm, na.rm = TRUE))

mean_traits_shootvol_merge <- merge(mean_traits_shootvol,phenotypic_data_growth,"Plant")

#Keep only one value per plant (ex: 2012, it's not only the values of 2012)
mean_traits_growth_f <- mean_traits_shootvol_merge %>%
  filter(Year == 2012)

##Basal area
mean_traits_growth_bis_f <- data.frame(phenotypic_data_growth_bis) %>%
  filter(across(c(SumAB.2021.cm2, StemLength.cm), ~ !is.na(.)))
```

```{r Growth phenology}
# Growth phenology

##Spring elong
#identify the number of measurement per plant
phenotypic_data_phenology_table <- data.frame(table(phenotypic_data_growth_pheno$Plant))

#filter the number of measurement to keep the maximum number of individuals
phenotypic_data_pheno_filtered <- phenotypic_data_growth_pheno %>%
  filter(Plant %in% phenotypic_data_phenology_table$Var1[phenotypic_data_phenology_table$Freq == 3])

#mean values of the traits per plant
mean_traits_pheno <- phenotypic_data_pheno_filtered %>%
  group_by(Plant) %>%
  summarize(mean_springelong = mean(ProportionSpringElongation, na.rm = TRUE))

mean_traits_pheno_merge <- merge(mean_traits_pheno,phenotypic_data_growth_pheno,"Plant")

#keep only one value per plant (ex: 2012, it's not only the values of 2012)
mean_traits_growth_pheno_f <- mean_traits_pheno_merge %>%
  filter(Year == 2012)
```

```{r Reproductive phenology}
# Reproductive phenology

##Reproduction
#identify the number of measurement per plant
phenotypic_data_repro_table <- data.frame(table(phenotypic_data_repro_pheno$Plant))

#filter the number of measurement to keep the maximum number of individuals
phenotypic_data_repro_filtered <- phenotypic_data_repro_pheno %>%
  filter(Plant %in% phenotypic_data_repro_table$Var1[phenotypic_data_repro_table$Freq == 3])

#mean values of the traits per plant
mean_traits_repro <- phenotypic_data_repro_filtered %>%
  group_by(Plant) %>%
  summarize(mean_proportion_open = mean(Proportion_total_open, na.rm = TRUE))

mean_traits_repro_merge <- merge(mean_traits_repro,phenotypic_data_repro_pheno,"Plant")

#keep only one value per plant (ex: 2012, it's not only the values of 2012)
mean_traits_repro_pheno_f <- mean_traits_repro_merge %>%
  filter(Year == 2012)
```

```{r Leaf_traits}
#Leaf_traits
phenotypic_data_leaftrait_table <- data.frame(table(phenotypic_data_leaf_traits$Plant))
#table(phenotypic_data_leaftrait_table$Freq)#we retained 4

#filter the number of measurement to keep the maximum number of individuals
phenotypic_data_leaftrait_filtered <- phenotypic_data_leaf_traits %>%
  filter(Plant %in% phenotypic_data_leaftrait_table$Var1[phenotypic_data_leaftrait_table$Freq == 4])

#mean values of the traits per plant
mean_traits_leaftraits <- phenotypic_data_leaftrait_filtered %>%
  group_by(Plant) %>%
  summarize(mean_StomDens = mean(StomDens.mm2, na.rm = TRUE),
            mean_leafthickness = mean(LeafThickness.mm, na.rm = TRUE),
            mean_LMA = mean(LMA.gm2,na.rm=T),
            mean_D13C = mean(D13C,na.rm=T))

mean_traits_leaftraits_merge <- merge(mean_traits_leaftraits,phenotypic_data_leaf_traits[,c(1:5)],"Plant")

#keep only one value per plant (ex: 2012, it's not only the values of 2012)
mean_traits_leaftraits_f <- mean_traits_leaftraits_merge %>%
  filter(Year == "Y2021")
```

## Selection of the populations with enought trees

We also checked the number of measured individuals per population, retaining only populations with more than two individuals.
```{r number of measured indiv per pop}
table(mean_traits_growth_f$Population)
#We removed the ACEBDO, LASENIA

table(mean_traits_growth_pheno_f$Population)
#We removed the ACEBDO, ALCOY, LASENIA Quesada pop

table(mean_traits_repro_pheno_f$Population)
#We removed the BOCAHUERGANO, JERTE, LASENIA,PUEBLALILLO and RASQUERA 

table(mean_traits_leaftraits_f$Population)
#we can remove: ACEBEDO, ALCOY, LASENIA, and QUESADA
```
## Graphical visualization

To select the type of distribution used in the GLMM models, we investigated the shape of the data distribution for each trait.
```{r phenotypic_df_config}

list_traits <- c("growth","growth_bis","growth_pheno","repro_pheno","leaftraits")
for(x in 1: length(list_traits)){
  
  name <- list_traits[x]
  df <- get(paste0("mean_traits_",name,"_f"))
  
df$Population<- as.factor(df$Population)
df$Plant <- as.factor(df$Plant)
df$Genet <- as.factor(df$Genet)

assign(paste0("phenotypic_data_",name),df)
}
```

```{r hist}
hist(phenotypic_data_growth$mean_AverageShootVolume)
#hist(phenotypic_data_growth_bis$SumAB.2021.cm2)
hist(phenotypic_data_growth_pheno$mean_springelong)
hist(phenotypic_data_repro_pheno$mean_proportion_open)
#hist(phenotypic_data_leaftraits$mean_StomDens)
hist(phenotypic_data_leaftraits$mean_leafthickness)
#hist(phenotypic_data_leaftraits$mean_LMA)
#hist(phenotypic_data_leaftraits$mean_D13C)
```

# MCMC GLMM models
    
We can now run the MCMC GLMM models for each trait. We need to specify the priors, as we are working with Bayesian models. We chose a non-informative prior due to the lack of prior information. The number of iterations was set to 1,500,000, with a burn-in period of 50,000 and a thinning interval of 500, sampling every 500 iterations. Each model was run four times per trait (four MCMC chains) to ensure stability. All traits follow a Gaussian distribution with continuous data.

## Trait related to growth
    
### Shoot Volume

For growth traits, as trees in the clonal bank vary in age, we used stem length as a covariate to account for differences in shoot volume associated with tree age. 

```{r shootvolume model, eval=FALSE, include=FALSE}
set.seed(3)

#phenotypic_data_growth$Sex <- as.factor(phenotypic_data_growth$Sex)
#phenotypic_data_growth_wo_Na <- phenotypic_data_growth %>%group_by(Sex) %>% drop_na()

#Set the prior info for the fixed variables: year and the randoms ones: Population and Plant
prior_ShootVol=list(R=list(V=1, nu=0.002),G=list((G1=list(V=1, nu=0.002)),(G2=list(V=1, nu=0.002)),(G3=list(V=1, nu=0.002))))

#We can perform the model
ShootVol<- mclapply(1:4, function(i) {#we can perform 4 MCMC 
  ShootVol<-MCMCglmm(mean_AverageShootVolume~1,random=~Population + Genet +mean_StemLength,prior=prior_ShootVol, family="gaussian", nitt=1500000, burnin=50000, thin=500, data=phenotypic_data_growth_wo_Na, pr=TRUE, verbose=F)
}, mc.cores=1)

#save the chains
growth_model_wo_plantID<- ShootVol
#save(ShootVol_model_wo_plantID,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/mean_years/ShootVol_model_wo_plantID.rda")
```

```{r load the MCMC growth }
load("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/mean_years/ShootVol_model_wo_plantID.rda")
growth_model_wo_plantID <- ShootVol_model_wo_plantID
```

New version by putting mean_StemLength as a fixed effect to calculate the slope and not and individual effect of each individuals (too much parameters)
```{r shootvolume model new, eval=FALSE, include=FALSE}
set.seed(3)

phenotypic_data_growth$Sex <- as.factor(phenotypic_data_growth$Sex)
phenotypic_data_growth_wo_Na <- phenotypic_data_growth %>%group_by(Sex) %>% drop_na()

#Set the prior info for the fixed variables: year and the randoms ones: Population and Plant
prior_ShootVol=list(R=list(V=1, nu=0.002),G=list((G1=list(V=1, nu=0.002)),(G2=list(V=1, nu=0.002))))

#We can perform the model
ShootVol<- mclapply(1:4, function(i) {#we can perform 4 MCMC 
  ShootVol<-MCMCglmm(mean_AverageShootVolume~mean_StemLength,random=~Population + Genet,prior=prior_ShootVol, family="gaussian", nitt=1500000, burnin=50000, thin=500, data=phenotypic_data_growth_wo_Na, pr=TRUE, verbose=F)
}, mc.cores=1)

#save the chains
ShootVol_wo_plantID_correcteffect<- ShootVol
growth_newformulation_model_wo_plantID <- ShootVol
save(ShootVol_wo_plantID_correcteffect,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/mean_years/ShootVol_wo_plantID_correcteffect.rda")
```

## Trait related to growth phenology

### Spring elongation
```{r springelong model, eval=FALSE, include=FALSE}
set.seed(3)
#phenotypic_data_growth_pheno_wo_Na <- phenotypic_data_growth_pheno %>%group_by(Sex) %>% drop_na()
#phenotypic_data_growth_pheno_wo_Na$Sex <- as.factor(phenotypic_data_growth_pheno_wo_Na$Sex)

#set the prior info for the fixed variables: year and the randoms ones: Population and Plant
prior_springelong=list(R=list(V=1, nu=0.002),G=list((G1=list(V=1, nu=0.002)),(G2=list(V=1, nu=0.002))))

#we can perform the model

springelong<- mclapply(1:4, function(i) {#we can perform 4 MCMC 
  springelong<-MCMCglmm(mean_springelong~Sex,random=~Population + Genet,prior=prior_springelong, family="gaussian", nitt=1500000, burnin=50000, thin=500, data=phenotypic_data_growth_pheno_wo_Na, pr=TRUE, verbose=F) #the pheno is explain by the year as fixed because few number of parameters and by the Population and Plant factors, we are following a gaussian law due to the quantitative continuous type of the response variable (the pheno)
}, mc.cores=1)

#save the chains
growth_pheno_model_wo_plantID<- springelong
#save(springelong_model_wo_plantID,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/mean_years/springelong_model_wo_plantID.rda")
```

```{r load the MCMC growth pheno}
load("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/mean_years/springelong_model_wo_plantID.rda")
growth_pheno_model_wo_plantID <- springelong_model_wo_plantID
```

## Trait related to reproductive phenology

### Proportion open strobili
```{r mature Strobili model, eval=FALSE, include=FALSE}
set.seed(3)
#set the prior info for the fixed variables: year and the randoms ones: Population and Plant
prior_openstrob=list(R=list(V=1, nu=0.002),G=list((G1=list(V=1, nu=0.002)),(G2=list(V=1, nu=0.002))))

#we can perform the model

openstrob<- mclapply(1:4, function(i) {#we can perform 4 MCMC 
  openstrob<-MCMCglmm(mean_proportion_open~1,random=~Population + Genet,prior=prior_openstrob, family="gaussian", nitt=1500000, burnin=50000, thin=500, data=phenotypic_data_repro_pheno, pr=TRUE, verbose=F) #the pheno is explain by the year as fixed because few number of parameters and by the Population and Plant factors, we are following a poisson law due to the count type of the response variable (the pheno)
}, mc.cores=1)

#save the chains
openstrob_model_wo_plantID<- openstrob
#save(openstrob_model_wo_plantID,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/mean_years/openstrob_model_wo_plantID.rda")
```

```{r load the MCMC open strob}
load("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/mean_years/openstrob_model_wo_plantID.rda")
repro_pheno_model_wo_plantID <- openstrob_model_wo_plantID
```

## Water statues 

### Leaf thickness
```{r Leaf thickness model, eval=FALSE, include=FALSE}
set.seed(3)
#set the prior info for the fixed variables: year and the randoms ones: Population and Plant
prior_leaftraits=list(R=list(V=1, nu=0.002),G=list((G1=list(V=1, nu=0.002)),(G2=list(V=1, nu=0.002))))

#phenotypic_data_leaftraits$Sex<-as.factor(phenotypic_data_leaftraits$Sex)
#we can perform the model
leafthickness<- mclapply(1:4, function(i) {#we can perform 4 MCMC 
  leafthickness<-MCMCglmm(mean_leafthickness~1,random=~Population + Genet,prior=prior_leaftraits, family="gaussian", nitt=1500000, burnin=50000, thin=500, data=phenotypic_data_leaftraits, pr=TRUE, verbose=F) #the pheno is explain by the year as fixed because few number of parameters and by the Population and Plant factors, we are following a poisson law due to the count type of the response variable (the pheno)
}, mc.cores=1)

#save the chains
leafthickness_model_wo_plantID_wo_sex<- leafthickness
#save(leafthickness_model_wo_plantID_wo_sex,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/mean_years/leafthickness_model_wo_plantID_wo_sex.rda")
```

```{r load the MCMC leafthickness}
load("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/mean_years/leafthickness_model_wo_plantID.rda")
leafthickness_model_wo_plantID <-leafthickness_model_wo_plantID
```

# Evaluation of the models

To evaluate the performance of the models, we investigated several aspects: 

## Autocorrelation within MCMC

First, we checked the autocorrelation between values within the same MCMC chain to ensure that our thinning interval was sufficient.
```{r autocorrelation values MCMC, eval=F, echo=T}
list_name<- c("Population","Genet")
list_model <- c("growth","growth_pheno","repro_pheno","leafthickness")#"growth_bis","LMA","StomDens","D13C"

for(i in 1:length(list_model)){
  
  model_pheno <- get(paste0(list_model[i],"_model_wo_plantID"))
  name_pheno <- list_model[i]
for(x in 1:2){
  name <- list_name[x]
  
  acf_list <- lapply(model_pheno, function(model) {
  #Extract the MCMC samples for the random effects of provenance
  mcmc_samples <- mcmc(model$VCV[, name])  
  #Calculate ACF
  acf_values <- acf(as.numeric(mcmc_samples), plot = FALSE)  #Convert to numeric if needed
  return(acf_values)
})
  
  # Plot the first ACF
plot(acf_list[[1]], main=paste0("Autocorrelation for ",name," Random Effect ",name_pheno), col="black", lwd=2)

colors <- c("red", "blue", "green")  #Colors for the additional chains
for (i in 2:length(acf_list)) {
  lines(acf_list[[i]]$lag, acf_list[[i]]$acf, col=colors[i-1], lwd=2)
}
#Add a legend to distinguish between the chains
legend("topright", legend=paste("Chain", 1:length(model_pheno)), col=c("black", colors), lwd=2)

plot
#Save
png(paste0("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/figures_wo_plantID/checkmodel/autocorrelation/Autocorrelation_period_",name,"_",name_pheno,".png"));plot(acf_list[[1]], main=paste0("Autocorrelation for ",name," Random Effect ",name_pheno), col="black", lwd=2)
colors <- c("red", "blue", "green")
for (i in 2:length(acf_list)) {
  lines(acf_list[[i]]$lag, acf_list[[i]]$acf, col=colors[i-1], lwd=2)
}
legend("topright", legend=paste("Chain", 1:length(model_pheno)), col=c("black", colors), lwd=2);dev.off()
  }
}
```


```{r Rmardown 1, include=FALSE}
list_name<- c("Population","Genet")
list_model_rmarkdown <- c("growth")
for(i in 1:length(list_model_rmarkdown)){
  model_pheno <- get(paste0(list_model_rmarkdown[i],"_model_wo_plantID"))
  name_pheno <- list_model_rmarkdown[i]
for(x in 1:2){
  name <- list_name[x]
  acf_list <- lapply(model_pheno, function(model) {
  #Extract the MCMC samples for the random effects of provenance
  mcmc_samples <- mcmc(model$VCV[, name])  
  # Calculate ACF
  acf_values <- acf(as.numeric(mcmc_samples), plot = FALSE)  #Convert to numeric if needed
  return(acf_values)
})
  # Plot the first ACF
plot(acf_list[[1]], main=paste0("Autocorrelation for ",name," Random Effect ",name_pheno), col="black", lwd=2)

colors <- c("red", "blue", "green")  #Colors for the additional chains
for (i in 2:length(acf_list)) {
  lines(acf_list[[i]]$lag, acf_list[[i]]$acf, col=colors[i-1], lwd=2)
}
#Add a legend to distinguish between the chains
legend("topright", legend=paste("Chain", 1:length(model_pheno)), col=c("black", colors), lwd=2)
plot
  }
}
```
  
## Chains convergence  
  
Next, we ensured that the MCMC chains were converging.
```{r plot of MCMC chains, echo=T, eval=F}
for(i in 1:length(list_model)){
model_pheno <- get(paste0(list_model[i],"_model_wo_plantID"))
  name_pheno <- list_model[i]

for(x in 1: length(list_name)){
  
  name <- list_name[x]
  
  #Create MCMC lists for overall random effects (aggregated)
mcmc_list <- mcmc.list(lapply(model_pheno, function(model) {
  #Aggregate random effects for provenance
  mcmc(model$VCV[, name])
}))

par(mfrow=c(2,1), mar=c(4,4,2,1))  #Two plots: one for provenance, one for plant ID

#Plot trace plot for overall provenance random effect
plot(mcmc_list, auto.layout=FALSE, main=paste0("Trace Plot for Overall ",name," Random Effect ",name_pheno), col=c("red", "blue", "green", "black"))

#Save
png(paste0("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/figures_wo_plantID/checkmodel/convergence/MCMC_period_",name,"_",name_pheno,".png"));par(mfrow=c(2,1), mar=c(4,4,2,1))
plot(mcmc_list, auto.layout=FALSE, main=paste0("Trace Plot for Overall ",name," Random Effect ",name_pheno), col=c("red", "blue", "green", "black"));dev.off()
  }
}
```

```{r Rmarkdown 2, include=FALSE}
for(i in 1:length(list_model_rmarkdown)){
model_pheno <- get(paste0(list_model_rmarkdown[i],"_model_wo_plantID"))
  name_pheno <- list_model_rmarkdown[i]
for(x in 1: length(list_name)){
  name <- list_name[x]
  #Create MCMC lists for overall random effects (aggregated)
mcmc_list <- mcmc.list(lapply(model_pheno, function(model) {
  #Aggregate random effects for provenance
  mcmc(model$VCV[, name])
}))
par(mfrow=c(2,1), mar=c(4,4,2,1))  #Two plots: one for provenance, one for plant ID
#Plot trace plot for overall provenance random effect
plot(mcmc_list, auto.layout=FALSE, main=paste0("Trace Plot for Overall ",name," Random Effect ",name_pheno), col=c("red", "blue", "green", "black"))
  }
}
```

Graphically, the chains appear to converge. We calculated the Gelman-Rubin index to further assess convergence. 
```{r evaluating the models}
list_model <- c("growth","growth_pheno","repro_pheno","leafthickness")#"growth_bis","LMA","StomDens","D13C"

gelman_rubin_results <- list()

for(i in 1:length(list_model)){
  
  #Get the model object
  model_pheno <- get(paste0(list_model[i], "_model_wo_plantID"))
  name_pheno <- list_model[i]
  
  #Combine the MCMC chains into a single mcmc.list
  chaine_mc <- lapply(model_pheno, function(m) m$Sol)
  chaine_mc <- do.call(mcmc.list, chaine_mc)
  
  #Gelman-Rubin (GR) criterion to assess convergence across MCMC chains
  GRcriterion_index <- gelman.diag(chaine_mc)
  
  #Store the summary of the GR criterion in the list
  gelman_rubin_results[[name_pheno]] <- list(
    mpsrf = GRcriterion_index$mpsrf
  )
}
gelman_rubin_results
```

We can see that the Gelman-Rubin values are below 1.1, which is the defined threshold for convergence.

## Similarity of the posterior distribution across chains

We also examined the posterior distributions to assess the convergence of the MCMC results.
```{r posterior distribution, echo=T, eval=F}
for(i in 1:length(list_model)){
  model_pheno <- get(paste0(list_model[i],"_model_wo_plantID"))
  name_pheno <- list_model[i]

for(x in 1:length(list_name)){
  
  name <-list_name[x]
  
  density_list <- lapply(model_pheno, function(model) {
  #Extract the MCMC samples for the random effects of provenance
  mcmc_samples <- as.numeric(mcmc(model$VCV[, name])) 
  #Calculate density
  density_values <- density(mcmc_samples)
  return(density_values)
})
  #Limit of the plot
  max_density_value <- max(sapply(density_list, function(d) max(d$y)))
  
  #Plot the first density
plot(density_list[[1]], main=paste0("Posterior distribution of the ",name," Random Effect value ",name_pheno), col="black", lwd=2, xlab="Value", ylab="Density",ylim=c(0, max_density_value * 1.02))

#Overlay the remaining densities
colors <- c("red", "blue", "green")  #Colors for the additional chains
for (i in 2:length(density_list)) {
  lines(density_list[[i]], col=colors[i-1], lwd=2)
}

#Add a legend to distinguish between the chains
legend("topright", legend=paste("Chain", 1:length(model_pheno)), col=c("black", colors), lwd=2)

#Save
png(paste0("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/figures_wo_plantID/postdistrib/Posterior_distrib_period_",name,"_",name_pheno,".png"));plot(density_list[[1]], main=paste0("Posterior distribution of the ",name," Random Effect value ",name_pheno), col="black", lwd=2, xlab="Value", ylab="Density",ylim=c(0, max_density_value * 1.02))
colors <- c("red", "blue", "green")  # Colors for the additional chains
for (i in 2:length(density_list)) {
  lines(density_list[[i]], col=colors[i-1], lwd=2)
}
legend("topright", legend=paste("Chain", 1:length(model_pheno)), col=c("black", colors), lwd=2);dev.off()
  }
}
```

```{r Rmarkdown 3, include=FALSE}
for(i in 1:length(list_model_rmarkdown)){
  model_pheno <- get(paste0(list_model_rmarkdown[i],"_model_wo_plantID"))
  name_pheno <- list_model_rmarkdown[i]
for(x in 1:length(list_name)){
  name <-list_name[x]
  density_list <- lapply(model_pheno, function(model) {
  #Extract the MCMC samples for the random effects of provenance
  mcmc_samples <- as.numeric(mcmc(model$VCV[, name]))
  #Calculate density
  density_values <- density(mcmc_samples)
  return(density_values)
})
  #Limit of the plot
  max_density_value <- max(sapply(density_list, function(d) max(d$y)))
  #Plot the first density
plot(density_list[[1]], main=paste0("Posterior distribution of the ",name," Random Effect value ",name_pheno), col="black", lwd=2, xlab="Value", ylab="Density",ylim=c(0, max_density_value * 1.02))

#Overlay the remaining densities
colors <- c("red", "blue", "green")  #Colors for the additional chains
for (i in 2:length(density_list)) {
  lines(density_list[[i]], col=colors[i-1], lwd=2)
}
#Add a legend to distinguish between the chains
legend("topright", legend=paste("Chain", 1:length(model_pheno)), col=c("black", colors), lwd=2)
  }
}
```

# Blups values

Finally, we extracted the BLUP values from the models.

To calculate the BLUPs, we used the mean BLUP value across the four MCMC runs.
```{r blups estimate}
#list_model <- c("growth","growth_bis","growth_pheno","repro_pheno","leafthickness","LMA","StomDens","D13C")
list_model <- c("growth","growth_pheno","repro_pheno","leafthickness")#"growth_bis","LMA","StomDens"

for(i in 1:length(list_model)){
  model_pheno <- get(paste0(list_model[i],"_model_wo_plantID"))
  name_pheno <- list_model[i]
  
#BLUPs values
for(x in 1:4){
  
  model <- model_pheno[[x]] #Extract the chains from the model 
  blups<-data.frame(posterior.mode(model$Sol))
  assign(paste0("blups_",name_pheno,"_",x),blups)
  }
}
  
for(i in 1:length(list_model)){
  
  name_pheno <- list_model[i]
  
  MC1 <- get(paste0("blups_",name_pheno,"_1"))
  MC2 <- get(paste0("blups_",name_pheno,"_2"))
  MC3 <- get(paste0("blups_",name_pheno,"_3"))
  MC4 <- get(paste0("blups_",name_pheno,"_4"))

  Blups_df <- data.frame(MC1,MC2,MC3,MC4)
  Blups_df$mean_blup <- rowMeans(Blups_df)
  
write_xlsx(data.frame(row.names(Blups_df),Blups_df[,c(5)]),paste0("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/BLUPs_mean/Blups_",name_pheno,"final_period.xlsx"))
}
```


# Draft

```{r Correlation two type of Blups}
df_growth <- read_excel("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/BLUPs_mean/Blups_growthfinal_period.xlsx")

df_growth <- df_growth[c(2:27),]

df_growth_V2 <- read_excel("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/BLUPs_mean/Blups_growth_V2final_period.xlsx")
df_growth_V2 <- df_growth_V2[c(2:27),]

cor(df_growth$Blups_df...c.5..,df_growth_V2$Blups_df...c.5..)
```

We retained the full posterior distribution information rather than using a single point estimate, as suggested by Reviewer 2 to keep error information.

```{r retained full posterior, eval=FALSE, include=FALSE}
# 1. Define trait models and population filters
traits <- c("growth", "growth_pheno", "repro_pheno", "leafthickness")
pop_filters <- list(
  growth = c("ACEBEDO", "LASENIA"),
  growth_pheno = c("ACEBEDO", "ALCOY", "LASENIA", "QUESADA"),
  repro_pheno = c("BOCAHUERGANO", "JERTE", "LASENIA", "PUEBLALILLO", "RASQUERA"),
  leafthickness = c("ACEBEDO", "ALCOY", "LASENIA", "QUESADA")
)

# 2. Extract posterior random effects for "Population" from each trait model
extract_population_effects <- function(model_list) {
  pop_effects_list <- lapply(model_list, function(model) {
    ranef_matrix <- model$Sol[, grep("Population", colnames(model$Sol)), drop = FALSE]
    # clean names
    colnames(ranef_matrix) <- gsub(".*Population", "", colnames(ranef_matrix))
    return(as.matrix(ranef_matrix))
  })
  
  # Stack chains and return a single matrix
  do.call(rbind, pop_effects_list)
}

posterior_samples <- list()

for (trait in traits) {
  model <- get(paste0(trait, "_model_wo_plantID"))  # list of 4 chains
  posterior_matrix <- extract_population_effects(model)
  posterior_samples[[trait]] <- posterior_matrix
}

# 3. Align population names and build 3D posterior array
all_populations <- unique(unlist(lapply(posterior_samples, colnames)))
iterations_total <- nrow(posterior_samples[[1]]) * 4

posterior_array <- array(NA, dim = c(iterations_total, length(all_populations), length(traits)),
                         dimnames = list(NULL, all_populations, traits))

for (t in traits) {
  pops_t <- colnames(posterior_samples[[t]])
  pop_idx <- match(pops_t, all_populations)
  posterior_array[, pop_idx, t] <- posterior_samples[[t]]
}

# 4. Apply population exclusions
for (t in traits) {
  excluded_pops <- pop_filters[[t]]
  if (!is.null(excluded_pops)) {
    idx_trait <- which(traits == t)
    idx_pops <- which(all_populations %in% excluded_pops)
    posterior_array[, idx_pops, idx_trait] <- NA
  }
}

# 5. Standardize posterior values across populations (per trait, per iteration)
posterior_array_scaled <- posterior_array
for (i in 1:dim(posterior_array)[1]) {  # loop over iterations
  for (j in 1:dim(posterior_array)[3]) {  # loop over traits
    values <- posterior_array[i, , j]
    min_val <- min(values, na.rm = TRUE)
    max_val <- max(values, na.rm = TRUE)
    if (!is.na(min_val) && !is.na(max_val) && max_val != min_val) {
      posterior_array_scaled[i, , j] <- (values - min_val) / (max_val - min_val)
    }
  }
}

# 6. Compute Composite Fitness Index (CFI) for each iteration and population
CFI_matrix <- apply(posterior_array_scaled, c(1, 2), function(x) {
  valid_vals <- x[!is.na(x)]
  if (length(valid_vals) == 0) return(NA)
  mean(valid_vals)
})

# Result: CFI_matrix [iterations × populations]
CFI_summary <- data.frame(
  Population = all_populations,
  Mean_CFI = apply(CFI_matrix, 2, mean, na.rm = TRUE),
  CI_lower = apply(CFI_matrix, 2, quantile, probs = 0.025, na.rm = TRUE),
  CI_upper = apply(CFI_matrix, 2, quantile, probs = 0.975, na.rm = TRUE)
)

# View results
print(CFI_summary)
```

```{r Load GO predictions, eval=FALSE, include=FALSE}
#RDA standard GO
list_RDA_standard <- c("all","random","random_same_AF","LC","CG","random_AF_V2","all_outliers")
list_period <- c("CG2012","CG2021")
for(i in 1: length(list_period)){
  
    period <- list_period[i]

for(x in 1:length(list_RDA_standard)){
  name <- list_RDA_standard[x]

  
  load(paste0("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/Genomic_offset/Validation/GO/standard_GO/RDA/data/CG_period/GO_RDA_",name,"_",period,"_Taxus.Rdata"))
  }
}

#GF GO
list_GF_standard <- c("all","random","random_same_AF","LC","CG","random_AF_V2","all_outliers")
list_period <- c("2012","2021")
for(i in 1: length(list_period)){
  
   period <- list_period[i]
  
for(x in 1:length(list_GF_standard)){
  
  name <- list_GF_standard[x]

  
  load(paste0("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/Genomic_offset/Validation/GO/Standard_GO/GF/data/CG_period/GO_standard_GF_",name,"_",period,".Rdata"))
}
}
```


```{r correlation with GO, eval=FALSE, include=FALSE}
posterior_correlation <- function(posterior_matrix, GO_df, GO_col = 2) {
  # Ensure population names match
  common_pops <- intersect(colnames(posterior_matrix), GO_df$Population)
  
  # Reorder GO vector to match posterior matrix column order
  GO_vector <- GO_df[match(common_pops, GO_df$Population), GO_col]
  
  # Subset posterior to matching populations
  posterior_sub <- posterior_matrix[, common_pops, drop = FALSE]
  
  # Compute correlation for each iteration
  cor_values <- apply(posterior_sub, 1, function(x) {
    cor(x, GO_vector, use = "pairwise.complete.obs")
  })
  
  return(cor_values)
}

# ---- Prepare Output ----
posterior_cor_results <- data.frame(
  Method = character(),
  Model = character(),
  Trait = character(),
  Mean = numeric(),
  CI_lower = numeric(),
  CI_upper = numeric(),
  Prop_Positive = numeric(),
  stringsAsFactors = FALSE
)

list_GO_2012_RDA <- c("GO_RDA_all_CG2012_Taxus", "GO_RDA_random_same_AF_CG2012_Taxus", 
                      "GO_RDA_LC_CG2012_Taxus","GO_RDA_random_AF_V2_CG2012_Taxus","GO_RDA_all_outliers_CG2012_Taxus")#"GO_RDA_random_CG2012_Taxus",
list_GO_2021_RDA <- c("GO_RDA_all_CG2021_Taxus", "GO_RDA_random_same_AF_CG2021_Taxus", 
                      "GO_RDA_LC_CG2021_Taxus","GO_RDA_random_AF_V2_CG2021_Taxus","GO_RDA_all_outliers_CG2021_Taxus")#"GO_RDA_random_CG2021_Taxus",

# List of Gradient Forest genomic offsets for 2012 and 2021
list_GO_2012_GF <- c("GO_standard_GF_all_2012", "GO_standard_GF_random_same_AF_2012", 
                     "GO_standard_GF_LC_2012","GO_standard_GF_random_AF_V2_2012","GO_standard_GF_all_outliers_2012")#,"GO_standard_GF_random_2012"
list_GO_2021_GF <- c("GO_standard_GF_all_2021", "GO_standard_GF_random_same_AF_2021", 
                     "GO_standard_GF_LC_2021","GO_standard_GF_random_AF_V2_2021","GO_standard_GF_all_outliers_2021")#"GO_standard_GF_random_2021",

# Combine lists into one for easier processing
list_GO_2012 <- c(list_GO_2012_RDA, list_GO_2012_GF)
list_GO_2021 <- c(list_GO_2021_RDA, list_GO_2021_GF)

# Corresponding methods and models
list_method <- c(rep("RDA", 5), rep("GF", 5))  # 4 RDA models and 4 GF models

list_model <- c("all", "random_same_AF", "LC", "all", "random_same_AF", "LC")#"random",,"random"
list_model <- c("all", "random_same_AF", "outlier","random_same_AF_V2","all_outliers", "all", "random_same_AF", "outlier","random_same_AF_V2","all_outliers")#"random",,"random"

# Traits considered
#list_traits <- c("growth","growth_pheno","repro_pheno","leafthickness","LMA","StomDens","D13C")
list_traits <- c("growth","growth_pheno","repro_pheno","leafthickness","composite_fitness")


# ---- Loop through GO predictions ----
for (i in 1:10) {
  GO_pred_2012 <- get(list_GO_2012[i])
  GO_pred_2021 <- get(list_GO_2021[i])
  method <- list_method[i]
  model <- list_model[i]
  
  for (trait in list_traits) {
    
    # Choose trait-specific posterior matrix
    if (trait == "composite_fitness") {
      posterior_matrix <- CFI_matrix
      colnames(posterior_matrix) <- gsub("^\\.+", "", colnames(posterior_matrix))
      GO_df <- GO_pred_2021  # Use 2021 for CFI
    } else {
      posterior_matrix <- posterior_samples[[trait]]
      colnames(posterior_matrix) <- gsub("^\\.+", "", colnames(posterior_matrix))
      GO_df <- GO_pred_2012  # Use 2012 for individual traits
    }
    
    # Calculate posterior correlation distribution
    cor_samples <- posterior_correlation(posterior_matrix, GO_df)
    
    # Summarize
    posterior_cor_results <- rbind(posterior_cor_results, data.frame(
      Method = method,
      Model = model,
      Trait = trait,
      Mean = mean(cor_samples, na.rm = TRUE),
      CI_lower = quantile(cor_samples, 0.025, na.rm = TRUE),
      CI_upper = quantile(cor_samples, 0.975, na.rm = TRUE),
      Prop_Positive = mean(cor_samples > 0, na.rm = TRUE)
    ))
  }
}

# ---- Inspect results ----
print(posterior_cor_results)

hist(posterior_cor_results$Mean, breaks = 30, main = "Posterior correlation", xlab = "Correlation with GO")
abline(v = 0, col = "red", lty = 2)
```


## Mean value of CFI after accounting for uncertainty in trait values

```{r Pearson correlation, eval=FALSE, include=FALSE}
# List of RDA genomic offsets for 2012 and 2021
list_GO_2012_RDA <- c("GO_RDA_all_CG2012_Taxus","GO_RDA_random_CG2012_Taxus", "GO_RDA_random_same_AF_CG2012_Taxus", 
                      "GO_RDA_LC_CG2012_Taxus","GO_RDA_random_AF_V2_CG2012_Taxus","GO_RDA_all_outliers_CG2012_Taxus")
list_GO_2021_RDA <- c("GO_RDA_all_CG2021_Taxus","GO_RDA_random_CG2021_Taxus", "GO_RDA_random_same_AF_CG2021_Taxus", 
                      "GO_RDA_LC_CG2021_Taxus","GO_RDA_random_AF_V2_CG2021_Taxus","GO_RDA_all_outliers_CG2021_Taxus")

# List of Gradient Forest genomic offsets for 2012 and 2021
list_GO_2012_GF <- c("GO_standard_GF_all_2012","GO_standard_GF_random_2012", "GO_standard_GF_random_same_AF_2012", 
                     "GO_standard_GF_LC_2012","GO_standard_GF_random_AF_V2_2012","GO_standard_GF_all_outliers_2012")
list_GO_2021_GF <- c("GO_standard_GF_all_2021","GO_standard_GF_random_2021", "GO_standard_GF_random_same_AF_2021", 
                     "GO_standard_GF_LC_2021","GO_standard_GF_random_AF_V2_2021","GO_standard_GF_all_outliers_2021")

# Combine lists into one for easier processing
list_GO_2012 <- c(list_GO_2012_RDA, list_GO_2012_GF)
list_GO_2021 <- c(list_GO_2021_RDA, list_GO_2021_GF)

# Corresponding methods and models
list_method <- c(rep("RDA", 6), rep("GF", 6))  # 4 RDA models and 4 GF models

list_model <- c("all","random", "random_same_AF", "LC", "all","random", "random_same_AF", "LC")
list_model <- c("all","random", "random_same_AF", "outlier","random_same_AF_V2","all_outliers", "all","random", "random_same_AF", "outlier","random_same_AF_V2","all_outliers")

# Traits considered
#list_traits <- c("growth","growth_pheno","repro_pheno","leafthickness","LMA","StomDens","D13C")
list_traits <- c("CFI_summary")

# Create an empty dataframe to store correlations
correlation_df <- data.frame(
  Method = character(),
  Model = character(),
  Trait = character(),
  Correlation = numeric(),
  P_value = numeric(),
  stringsAsFactors = FALSE
)

# Loop over each Genomic Offset for both RDA and GF models
for(i in 1:12) {  # Now we have 8 models (4 RDA + 4 GF)
  GO_pred_2012 <- get(list_GO_2012[i])
  GO_pred_2021 <- get(list_GO_2021[i])
  method <- list_method[i]
  model <- list_model[i]
  
  # Loop over each trait
  for(x in 1:length(list_traits)) {
    trait <- list_traits[x]
    
    # Use CG2021 data for Height, and CG2012 for other traits
    if (trait == "Leafthickness" || trait=="CFI_summary") {
      df_trait <- CFI_summary
      df_trait$Population <- gsub("^\\.+", "", df_trait$Population)
      # Merge data frames based on population for CG2021
      merged_df <- merge(df_trait, GO_pred_2021, by = "Population", suffixes = c(".trait", ".GO"))
    } else {
      df_trait <- get(paste0("df_", trait,"_final"))
      
      # Merge data frames based on population for CG2012
      merged_df <- merge(df_trait, GO_pred_2012, by = "Population", suffixes = c(".trait", ".GO"))
    }
    
    # Calculate the correlation
    correlation <- cor(merged_df[, 2], merged_df[, 5])
    
  pval <- cor.test(merged_df[, 2],merged_df[, 5])
 P_value <- pval$p.value
    
    # Store the correlation in the dataframe
    correlation_df <- rbind(correlation_df, data.frame(Method = method, Model = model, Trait = trait, Correlation = correlation, P_value= P_value))
  }
}
# Print the correlation data frame
#print(correlation_df)
```








## Phenotypic values not using BLUPs (not using population as a random factor), as suggested by Reviewer 2


As the reviewer suggested, "Is BLUP for population i better than a simple mean for a given population? If yes, please explain how BLUP improves further inferences." We will test whether not using BLUPs provides similar results. To do this, we will run a model for each phenotypic trait accounting for covariates, then calculate the mean value for each individual grouped by population to obtain the phenotypic mean per population. 



### Trait related to growth
    
#### Shoot Volume

For growth traits, as trees in the clonal bank vary in age, we used stem length as a covariate to account for differences in shoot volume associated with tree age.

```{r shootvolume model no blups test, eval=FALSE, include=FALSE}
set.seed(3)

phenotypic_data_growth$Sex <- as.factor(phenotypic_data_growth$Sex)
phenotypic_data_growth_wo_Na <- phenotypic_data_growth %>%group_by(Sex) %>% drop_na()

#set the prior info for the fixed variables: year and the randoms ones: Population and Plant
prior_ShootVol=list(R=list(V=1, nu=0.002),G=list((G1=list(V=1, nu=0.002)),(G2=list(V=1, nu=0.002))))

#we can perform the model
ShootVol_covariates<- mclapply(1:4, function(i) {#we can perform 4 MCMC 
  ShootVol_covariates<-MCMCglmm(mean_AverageShootVolume~1,random=~ Genet +mean_StemLength,prior=prior_ShootVol, family="gaussian", nitt=1500000, burnin=50000, thin=500, data=phenotypic_data_growth, pr=TRUE, verbose=F) #the pheno is explain by the year as fixed because few number of parameters and by the Population and Plant factors, we are following a gaussian law due to the quantitative continuous type of the response variable (the pheno)
}, mc.cores=1)

#save the chains
growth_model_covariates<- ShootVol_covariates
save(growth_model_covariates,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/growth_model_covariates.rda")
```

```{r load the MCMC growth no blups test, eval=FALSE, include=FALSE}
load("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/growth_model_covariates.rda")
growth_model_covariates <- growth_model_covariates
```

```{r extract population values shootvol bis bis , eval=FALSE, include=FALSE}
all_sols <- do.call(rbind, lapply(ShootVol_covariates, function(model) model$Sol))

# Extract Genet random effects
genet_effects_all <- all_sols[, grepl("^Genet\\.", colnames(all_sols))]

# Compute posterior mean of each Genet effect across all samples
genet_means <- colMeans(genet_effects_all)

# Extract clean Genet names
genet_names <- gsub("^Genet\\.", "", names(genet_means))
genet_map <- data.frame(Genet = genet_names, genet_effect = genet_means)

phenotypic_data_growth <- phenotypic_data_growth %>%
  left_join(genet_map, by = "Genet")


stemlength_effects_all <- all_sols[, grepl("^mean_StemLength\\.", colnames(all_sols))]

# Compute posterior mean of each Genet effect across all samples
stemlength_means <- colMeans(stemlength_effects_all)

# Extract clean Genet names
stemlength_names <- gsub("^mean_StemLength\\.", "", names(stemlength_means))
stemlength_map <- data.frame(StemLength.cm = stemlength_names, stemlength_effect = stemlength_means)

# Merge with your data
phenotypic_data_growth$StemLength.cm<- as.factor(phenotypic_data_growth$StemLength.cm)
phenotypic_data_growth <- phenotypic_data_growth %>%
  left_join(stemlength_map, by = "StemLength.cm")


# Adjust phenotype: observed - genet effect
phenotypic_data_growth <- phenotypic_data_growth %>%
  mutate(adjusted_growth = mean_AverageShootVolume - genet_effect - stemlength_effect)#

pop_mean_adjusted_growth <- phenotypic_data_growth %>%
  group_by(Population) %>%
  summarise(mean_adjusted_growth = mean(adjusted_growth, na.rm = TRUE))

save(pop_mean_adjusted_growth,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/values/pop_mean_adjusted_growth.Rdata")
```

Reduce 

```{r shootvolume model no blups, eval=FALSE, include=FALSE}
set.seed(3)

phenotypic_data_growth$Sex <- as.factor(phenotypic_data_growth$Sex)
phenotypic_data_growth_wo_Na <- phenotypic_data_growth %>%group_by(Sex) %>% drop_na()

#set the prior info for the fixed variables: year and the randoms ones: Population and Plant
prior_ShootVol=list(R=list(V=1, nu=0.002),G=list((G1=list(V=1, nu=0.002)),(G2=list(V=1, nu=0.002))))

#we can perform the model
ShootVol_covariates_reduce<- mclapply(1:4, function(i) {#we can perform 4 MCMC 
  ShootVol_covariates_reduce<-MCMCglmm(mean_AverageShootVolume~1,random=~ Genet +mean_StemLength,prior=prior_ShootVol, family="gaussian", nitt=1500000, burnin=50000, thin=500, data=phenotypic_data_growth_wo_Na, pr=TRUE, verbose=F) #the pheno is explain by the year as fixed because few number of parameters and by the Population and Plant factors, we are following a gaussian law due to the quantitative continuous type of the response variable (the pheno)
}, mc.cores=1)

#save the chains
growth_model_covariates_reduce<- ShootVol_covariates_reduce
save(growth_model_covariates_reduce,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/growth_model_covariates_reduce.rda")
```

```{r load the MCMC growth no blups, eval=FALSE, include=FALSE}
load("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/growth_model_covariates_reduce.rda")
growth_model_covariates_reduce <- growth_model_covariates_reduce
```

```{r extract population values openstrob test, eval=FALSE, include=FALSE}
all_sols <- do.call(rbind, lapply(ShootVol_covariates_reduce, function(model) model$Sol))

# Extract Genet random effects
genet_effects_all <- all_sols[, grepl("^Genet\\.", colnames(all_sols))]

# Compute posterior mean of each Genet effect across all samples
genet_means <- colMeans(genet_effects_all)

# Extract clean Genet names
genet_names <- gsub("^Genet\\.", "", names(genet_means))
genet_map <- data.frame(Genet = genet_names, genet_effect = genet_means)

phenotypic_data_growth_wo_Na <- phenotypic_data_growth_wo_Na %>%
  left_join(genet_map, by = "Genet")


stemlength_effects_all <- all_sols[, grepl("^mean_StemLength\\.", colnames(all_sols))]

# Compute posterior mean of each Genet effect across all samples
stemlength_means <- colMeans(stemlength_effects_all)

# Extract clean Genet names
stemlength_names <- gsub("^mean_StemLength\\.", "", names(stemlength_means))
stemlength_map <- data.frame(StemLength.cm = stemlength_names, stemlength_effect = stemlength_means)

# Merge with your data
phenotypic_data_growth_wo_Na$StemLength.cm<- as.factor(phenotypic_data_growth_wo_Na$StemLength.cm)
phenotypic_data_growth_wo_Na <- phenotypic_data_growth_wo_Na %>%
  left_join(stemlength_map, by = "StemLength.cm")


# Adjust phenotype: observed - genet effect
phenotypic_data_growth_wo_Na <- phenotypic_data_growth_wo_Na %>%
  mutate(adjusted_growth = mean_AverageShootVolume - genet_effect - stemlength_effect.y.y)#

pop_mean_adjusted_growth_reduce <- phenotypic_data_growth_wo_Na %>%
  group_by(Population) %>%
  summarise(mean_adjusted_growth = mean(adjusted_growth, na.rm = TRUE))

save(pop_mean_adjusted_growth_reduce,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/values/pop_mean_adjusted_growth_reduce.Rdata")
```

Fixed effect 
```{r shootvolume model no blups fixed, eval=FALSE, include=FALSE}
set.seed(3)

#phenotypic_data_growth$Sex <- as.factor(phenotypic_data_growth$Sex)
#phenotypic_data_growth_wo_Na <- phenotypic_data_growth %>%group_by(Sex) %>% drop_na()

#set the prior info for the fixed variables: year and the randoms ones: Population and Plant
prior_ShootVol=list(R=list(V=1, nu=0.002),G=list((G1=list(V=1, nu=0.002))))

#we can perform the model
ShootVol_covariates_fixed<- mclapply(1:4, function(i) {#we can perform 4 MCMC 
  ShootVol_covariates_fixed<-MCMCglmm(mean_AverageShootVolume~mean_StemLength,random=~ Genet,prior=prior_ShootVol, family="gaussian", nitt=1500000, burnin=50000, thin=500, data=phenotypic_data_growth, pr=TRUE, verbose=F) #the pheno is explain by the year as fixed because few number of parameters and by the Population and Plant factors, we are following a gaussian law due to the quantitative continuous type of the response variable (the pheno)
}, mc.cores=1)

#save the chains
growth_model_covariates_fixed<- ShootVol_covariates_fixed
save(growth_model_covariates_fixed,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/growth_model_covariates_fixed.rda")
```

```{r load the MCMC growth no blups testbis, eval=FALSE, include=FALSE}
load("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/growth_model_covariates_fixed.rda")
growth_model_covariates_fixed <- growth_model_covariates_fixed
```

```{r extract population values openstrob test bis, eval=FALSE, include=FALSE}
all_sols <- do.call(rbind, lapply(growth_model_covariates_fixed, function(model) model$Sol))

# Extract Genet random effects
genet_effects_all <- all_sols[, grepl("^Genet\\.", colnames(all_sols))]

# Compute posterior mean of each Genet effect across all samples
genet_means <- colMeans(genet_effects_all)

# Extract clean Genet names
genet_names <- gsub("^Genet\\.", "", names(genet_means))
genet_map <- data.frame(Genet = genet_names, genet_effect = genet_means)

phenotypic_data_growth <- phenotypic_data_growth %>%
  left_join(genet_map, by = "Genet")


stemlength_effect <- mean(all_sols[, "mean_StemLength"])
# Adjust phenotype: observed - genet effect - fixed effect * stem length
phenotypic_data_growth <- phenotypic_data_growth %>%
  mutate(adjusted_growth = mean_AverageShootVolume - genet_effect - mean_StemLength * stemlength_effect)

# Summarise per population
pop_mean_adjusted_growth_fixed <- phenotypic_data_growth %>%
  group_by(Population) %>%
  summarise(mean_adjusted_growth = mean(adjusted_growth, na.rm = TRUE))

save(pop_mean_adjusted_growth_fixed,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/values/pop_mean_adjusted_growth_fixed.Rdata")
```

## Trait related to growth phenology

### Spring elongation
```{r springelong model no blups, eval=FALSE, include=FALSE}
set.seed(3)
#phenotypic_data_growth_pheno_wo_Na <- phenotypic_data_growth_pheno %>%group_by(Sex) %>% drop_na()
#phenotypic_data_growth_pheno_wo_Na$Sex <- as.factor(phenotypic_data_growth_pheno_wo_Na$Sex)

#set the prior info for the fixed variables: year and the randoms ones: Population and Plant
prior_springelong=list(R=list(V=1, nu=0.002),G=list((G1=list(V=1, nu=0.002))))

#we can perform the model

springelong_model_covariates<- mclapply(1:4, function(i) {#we can perform 4 MCMC 
  springelong_model_covariates<-MCMCglmm(mean_springelong~1,random=~ Genet,prior=prior_springelong, family="gaussian", nitt=1500000, burnin=50000, thin=500, data=phenotypic_data_growth_pheno, pr=TRUE, verbose=F) #the pheno is explain by the year as fixed because few number of parameters and by the Population and Plant factors, we are following a gaussian law due to the quantitative continuous type of the response variable (the pheno)
}, mc.cores=1)

#save the chains
growth_pheno_model_covariates <- springelong_model_covariates
save(growth_pheno_model_covariates,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/growth_pheno_model_covariates.rda")
```

```{r load the MCMC growth pheno no blups, eval=FALSE, include=FALSE}
load("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/growth_pheno_model_covariates.rda")
growth_pheno_model_covariates <- growth_pheno_model_covariates
```

```{r extract population values openstrob test bis bis, eval=FALSE, include=FALSE}
all_sols <- do.call(rbind, lapply(growth_pheno_model_covariates, function(model) model$Sol))

# Extract Genet random effects
genet_effects_all <- all_sols[, grepl("^Genet\\.", colnames(all_sols))]

# Compute posterior mean of each Genet effect across all samples
genet_means <- colMeans(genet_effects_all)

# Extract clean Genet names
genet_names <- gsub("^Genet\\.", "", names(genet_means))
genet_map <- data.frame(Genet = genet_names, genet_effect = genet_means)

# Merge with your data
library(dplyr)
phenotypic_data_growth_pheno <- phenotypic_data_growth_pheno %>%
  left_join(genet_map, by = "Genet")

# Adjust phenotype: observed - genet effect
phenotypic_data_growth_pheno <- phenotypic_data_growth_pheno %>%
  mutate(adjusted_growthpheno = mean_springelong - genet_effect)

pop_mean_adjusted_growthpheno <- phenotypic_data_growth_pheno %>%
  group_by(Population) %>%
  summarise(mean_adjusted_growthpheno = mean(adjusted_growthpheno, na.rm = TRUE))

save(pop_mean_adjusted_growthpheno,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/values/pop_mean_adjusted_growthpheno.Rdata")
```



## Trait related to reproductive phenology

### Proportion open strobili
```{r mature Strobili model no blups, eval=FALSE, include=FALSE}
set.seed(3)
#set the prior info for the fixed variables: year and the randoms ones: Population and Plant
prior_openstrob=list(R=list(V=1, nu=0.002),G=list((G1=list(V=1, nu=0.002))))

#we can perform the model

openstrob_model_covariates<- mclapply(1:4, function(i) {#we can perform 4 MCMC 
  openstrob_model_covariates<-MCMCglmm(mean_proportion_open~1,random=~ Genet,prior=prior_openstrob, family="gaussian", nitt=1500000, burnin=50000, thin=500, data=phenotypic_data_repro_pheno, pr=TRUE, verbose=F) #the pheno is explain by the year as fixed because few number of parameters and by the Population and Plant factors, we are following a poisson law due to the count type of the response variable (the pheno)
}, mc.cores=1)

#save the chains
openstrob_model_covariates<- openstrob_model_covariates
save(openstrob_model_covariates,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/openstrob_model_covariates.rda")
```

```{r load the MCMC open strob no blups, eval=FALSE, include=FALSE}
load("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/openstrob_model_covariates.rda")
openstrob_model_covariates <- openstrob_model_covariates
```

```{r extract population values openstrob, eval=FALSE, include=FALSE}
all_sols <- do.call(rbind, lapply(openstrob_model_covariates, function(model) model$Sol))

# Extract Genet random effects
genet_effects_all <- all_sols[, grepl("^Genet\\.", colnames(all_sols))]

# Compute posterior mean of each Genet effect across all samples
genet_means <- colMeans(genet_effects_all)

# Extract clean Genet names
genet_names <- gsub("^Genet\\.", "", names(genet_means))
genet_map <- data.frame(Genet = genet_names, genet_effect = genet_means)

# Merge with your data
library(dplyr)
phenotypic_data_repro_pheno <- phenotypic_data_repro_pheno %>%
  left_join(genet_map, by = "Genet")

# Adjust phenotype: observed - genet effect
phenotypic_data_repro_pheno <- phenotypic_data_repro_pheno %>%
  mutate(adjusted_pheno = mean_proportion_open - genet_effect)

pop_mean_adjusted_repropheno <- phenotypic_data_repro_pheno %>%
  group_by(Population) %>%
  summarise(mean_adjusted_pheno = mean(adjusted_pheno, na.rm = TRUE))

save(pop_mean_adjusted_repropheno,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/values/pop_mean_adjusted_repropheno.Rdata")
```


## Water statues 

### Leaf thickness
```{r Leaf thickness model no blups, eval=FALSE, include=FALSE}
set.seed(3)
#set the prior info for the fixed variables: year and the randoms ones: Population and Plant
prior_leaftraits=list(R=list(V=1, nu=0.002),G=list((G1=list(V=1, nu=0.002))))

#phenotypic_data_leaftraits$Sex<-as.factor(phenotypic_data_leaftraits$Sex)
#we can perform the model
leafthickness_model_covariates<- mclapply(1:4, function(i) {#we can perform 4 MCMC 
  leafthickness_model_covariates<-MCMCglmm(mean_leafthickness~1,random=~ Genet,prior=prior_leaftraits, family="gaussian", nitt=1500000, burnin=50000, thin=500, data=phenotypic_data_leaftraits, pr=TRUE, verbose=F) #the pheno is explain by the year as fixed because few number of parameters and by the Population and Plant factors, we are following a poisson law due to the count type of the response variable (the pheno)
}, mc.cores=1)

#save the chains
leafthickness_model_covariates<- leafthickness_model_covariates
save(leafthickness_model_covariates,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/leafthickness_model_covariates.rda")
```

```{r extract population values openstrob test bis bis , eval=FALSE, include=FALSE}
all_sols <- do.call(rbind, lapply(leafthickness_model_covariates, function(model) model$Sol))

# Extract Genet random effects
genet_effects_all <- all_sols[, grepl("^Genet\\.", colnames(all_sols))]

# Compute posterior mean of each Genet effect across all samples
genet_means <- colMeans(genet_effects_all)

# Extract clean Genet names
genet_names <- gsub("^Genet\\.", "", names(genet_means))
genet_map <- data.frame(Genet = genet_names, genet_effect = genet_means)

# Merge with your data
library(dplyr)
phenotypic_data_leaftraits <- phenotypic_data_leaftraits %>%
  left_join(genet_map, by = "Genet")

# Adjust phenotype: observed - genet effect
phenotypic_data_leaftraits <- phenotypic_data_leaftraits %>%
  mutate(adjusted_leafthick = mean_leafthickness - genet_effect)

pop_mean_adjusted_leafthick <- phenotypic_data_leaftraits %>%
  group_by(Population) %>%
  summarise(mean_adjusted_leafthick = mean(adjusted_leafthick, na.rm = TRUE))

save(pop_mean_adjusted_leafthick,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/values/pop_mean_adjusted_leafthick.Rdata")
```


```{r load the MCMC leafthickness no blups, eval=FALSE, include=FALSE}
load("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/Covariate_model/leafthickness_model_covariates.rda")
leafthickness_model_covariates <-leafthickness_model_covariates
```


Traits: 

Basal area

```{r Basal area model, eval=FALSE, include=FALSE}
set.seed(3)

#set the prior info for the fixed variables: year and the randoms ones: Population and Plant
prior_Basal_area=list(R=list(V=1, nu=0.002),G=list((G1=list(V=1, nu=0.002)),(G2=list(V=1, nu=0.002)),(G3=list(V=1, nu=0.002))))

#we can perform the model
Basal_area<- mclapply(1:4, function(i) {#we can perform 4 MCMC 
  Basal_area<-MCMCglmm(SumAB.2021.cm2~1,random=~Population + Genet +StemLength.cm,prior=prior_Basal_area, family="gaussian", nitt=1500000, burnin=50000, thin=500, data=phenotypic_data_growth_bis, pr=TRUE, verbose=F) #the pheno is explain by the year as fixed because few number of parameters and by the Population and Plant factors, we are following a gaussian law due to the quantitative continuous type of the response variable (the pheno)
}, mc.cores=1)

#save the chains
Basal_area_model_wo_plantID<- Basal_area
#save(Basal_area_model_wo_plantID,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/mean_years/Basal_area_model_wo_plantID.rda")
```

```{r load the MCMC growth_bis, eval=FALSE, include=FALSE}
load("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/mean_years/Basal_area_model_wo_plantID.rda")
growth_bis_model_wo_plantID <- Basal_area_model_wo_plantID
```

LMA

```{r LMA model, eval=FALSE, include=FALSE}
set.seed(3)
#set the prior info for the fixed variables: year and the randoms ones: Population and Plant
prior_leaftraits=list(R=list(V=1, nu=0.002),G=list((G1=list(V=1, nu=0.002)),(G2=list(V=1, nu=0.002))))

phenotypic_data_leaftraits$Sex<-as.factor(phenotypic_data_leaftraits$Sex)
#we can perform the model
LMA<- mclapply(1:4, function(i) {#we can perform 4 MCMC 
  LMA<-MCMCglmm(mean_LMA~1,random=~Population + Genet,prior=prior_leaftraits, family="gaussian", nitt=1500000, burnin=50000, thin=500, data=phenotypic_data_leaftraits, pr=TRUE, verbose=F) #the pheno is explain by the year as fixed because few number of parameters and by the Population and Plant factors, we are following a poisson law due to the count type of the response variable (the pheno)
}, mc.cores=1)

#save the chains
LMA_model_wo_plantID_wo_sex<- LMA
#save(LMA_model_wo_plantID_wo_sex,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/mean_years/LMA_model_wo_plantID_wo_sex.rda")
```

```{r load the MCMC LMA, eval=FALSE, include=FALSE}
load("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/mean_years/LMA_model_wo_plantID.rda")

LMA_model_wo_plantID <-LMA_model_wo_plantID
```


StomDens

```{r StomDens model, eval=FALSE, include=FALSE}
set.seed(3)
#set the prior info for the fixed variables: year and the randoms ones: Population and Plant
prior_leaftraits=list(R=list(V=1, nu=0.002),G=list((G1=list(V=1, nu=0.002)),(G2=list(V=1, nu=0.002))))

phenotypic_data_leaftraits$Sex<-as.factor(phenotypic_data_leaftraits$Sex)
#we can perform the model
StomDens<- mclapply(1:4, function(i) {#we can perform 4 MCMC 
  StomDens<-MCMCglmm(mean_StomDens~1,random=~Population + Genet,prior=prior_leaftraits, family="gaussian", nitt=1500000, burnin=50000, thin=500, data=phenotypic_data_leaftraits, pr=TRUE, verbose=F) #the pheno is explain by the year as fixed because few number of parameters and by the Population and Plant factors, we are following a poisson law due to the count type of the response variable (the pheno)
}, mc.cores=1)

#save the chains
StomDens_model_wo_plantID_wo_sex<- StomDens
#save(StomDens_model_wo_plantID_wo_sex,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/mean_years/StomDens_model_wo_plantID_wo_sex.rda")
```

```{r load the MCMC Stomdens, eval=FALSE, include=FALSE}
load("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/mean_years/StomDens_model_wo_plantID_wo_sex.rda")

StomDens_model_wo_plantID <- StomDens_model_wo_plantID_wo_sex
```


D13C

```{r D13C model,eval=FALSE, include=FALSE}
set.seed(3)
#set the prior info for the fixed variables: year and the randoms ones: Population and Plant
prior_leaftraits=list(R=list(V=1, nu=0.002),G=list((G1=list(V=1, nu=0.002)),(G2=list(V=1, nu=0.002))))

phenotypic_data_leaftraits$Sex<-as.factor(phenotypic_data_leaftraits$Sex)
#we can perform the model
D13C<- mclapply(1:4, function(i) {#we can perform 4 MCMC 
  D13C<-MCMCglmm(mean_D13C~Sex,random=~Population + Genet,prior=prior_leaftraits, family="gaussian", nitt=1500000, burnin=50000, thin=500, data=phenotypic_data_leaftraits, pr=TRUE, verbose=F) #the pheno is explain by the year as fixed because few number of parameters and by the Population and Plant factors, we are following a poisson law due to the count type of the response variable (the pheno)
}, mc.cores=1)

#save the chains
D13C_model_wo_plantID<- D13C
#save(D13C_model_wo_plantID,file="C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/mean_years/D13C_model_wo_plantID.rda")
```

```{r load the MCMC,eval=FALSE, include=FALSE}
load("C:/Users/tfrancisco/Documents/Thesis/Results/species/taxus/phenotypic_data/mean_years/D13C_model_wo_plantID.rda")
```